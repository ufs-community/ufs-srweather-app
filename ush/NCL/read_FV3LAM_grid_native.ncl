;
; **********************************************************************
;
; File name: read_FV3LAM_grid_native.ncl
; Author: Gerard Ketefian
;
; Description:
; ^^^^^^^^^^^
; This function returns the file names, dimensions, cell center coordinates, 
; and cell vertex coordinates of the grids associated with the specified 
; FV3 cubed-sphere tiles (tile_inds).  If get_tile_bdies is set to True, 
; it also returns the coordinates of those grid cell vertices that lie on 
; the boundary of each specified tile.
;
; The input arguments to this function are as follows:
;
; expt_dir:
; This is the experiment directory created by the FV3SAR workflow generation 
; script.  The grid specification files corresponding to the cubed-sphere 
; tiles are within subdirectories under this directory.
;
; gtype:
; This is a string containing the type of the FV3 cubed-sphere grid being 
; read in.  For files generated by the FV3SAR workflow, this will be equal 
; to "regional".
; 
; cres:
; This is the C-resolution of the global cubed-sphere grid that serves
; as the "parent" of the regional grid.  It consists of the character 
; "C" followed by an interger that is equal to the number of grid cells
; in each of the two horizontal directions (say x and y) on each of the
; six tiles of the parent global grid.  Note that this number is in general 
; not equal to the number of grid cells on the regional grid (i.e. the 
; one on tile 7) because the latter is given by the former multiplied by 
; a refinement factor (an integer) that is normally greater than 1.
;
; tile_inds:
; The indices of the tiles (associated with ither the parent global grid
; or the regional grid) to consider in this function.
;
; get_tile_bdies:
; A logical variable that specifies whether arrays containing the coordinates 
; of grid cell vertices that lie on the boundary of each tile specified 
; in tile_inds are to be extracted and returned.
;
; nhalo_T7:
; The width of the halo (in units of grid cells) included in the grid 
; specification file for the regional grid (tile 7).  If tile_inds includes 
; tile 7, then this is used to form the name of the grid file for that 
; tile.  Also, if tile_inds includes tile 7 and if remove_rgnl_halo is 
; set to True, then a halo of width nhalo_T7 is removed from any arrays 
; read in from the tile 7 grid file.  This is not used if tile_inds does 
; not include tile 7.
;
; remove_rgnl_halo:
; Flag indicating whether to remove a halo of width nhalo_T7 from any
; arrays read in from the tile 7 grid file.  This is not used if tile_inds 
; does not include tile 7.
;
; **********************************************************************
;
loadscript(lib_location + "special_chars.ncl")
loadscript(lib_location + "strcmp_exact.ncl")
loadscript(lib_location + "strpad.ncl")
loadscript(lib_location + "get_rect_grid_bdy.ncl")
loadscript(lib_location + "get_rect_grid_corners.ncl")
loadscript(lib_location + "adjust_longitude_range.ncl")

undef("read_FV3LAM_grid_native")

function read_FV3LAM_grid_native( \
         expt_dir:string, \
         gtype:string, \
         cres:string, \
         tile_inds:integer, \
         get_tile_bdies:logical, \
         nhalo_T7:integer, \
         remove_rgnl_halo:logical)

local num_tiles_to_plot, \
\
      grid_fn_all_tiles, remove_halo_all_tiles, \
\
      nhSG_all_tiles, nxhSG_all_tiles, nyhSG_all_tiles, \
      nxSG_all_tiles, nySG_all_tiles, \
      nh_all_tiles, nxh_all_tiles, nyh_all_tiles, \
      nx_all_tiles, ny_all_tiles, \
\
      coord_data_type_all_tiles, \
\
      nn, msg, underline, n_tile, grid_fn, fp, \
      tile_SG_dims, \
\
      coord_data_type, match_found, match_by_elem, \
\
      lon_cntrs_all_tiles_unstruc, lat_cntrs_all_tiles_unstruc, \
      lon_verts_all_tiles_unstruc, lat_verts_all_tiles_unstruc, \
      lon_bdy_all_tiles, lat_bdy_all_tiles, \
\
      lon_tile_cntr_all_tiles, lat_tile_cntr_all_tiles, \
      lon_tile_corners_face_midpts_all_tiles, \
      lat_tile_corners_face_midpts_all_tiles, \
\
      nhSG, nxhSG, nyhSG, nxSG, nySG, \
      nh, nxh, nyh, nx, ny, \
      remove_halo, \
\
      lon_verts_SG_crnt_tile, lat_verts_SG_crnt_tile, \
      lon_verts_crnt_tile, lat_verts_crnt_tile, \
      lon_cntrs_crnt_tile, lat_cntrs_crnt_tile, \
\
      repeat_last_point, array_order, bdy_info, \
      lon_bdy_crnt_tile, lat_bdy_crnt_tile, \
\
      x_is_longitude, opts, corner_info, corner_lons, corner_lats, \
      fmt_str, lon_str, lat_str, \
      i_left, i_cntr, i_rght, j_bot, j_mid, j_top, \
      loc_names, i, \
\
      lon_cntrs_crnt_tile_unstruc, lat_cntrs_crnt_tile_unstruc, \
      lon_verts_crnt_tile_unstruc, lat_verts_crnt_tile_unstruc, \
\
      grid_info

begin
;
; **********************************************************************
;
; If not already defined, define the string separator_line that serves
; as a separator line between different sections of printout.
;
; **********************************************************************
;
  if (.not. isvar("separator_line")) then
    separator_line := repeat_str("=", 72)
  end if
;
; **********************************************************************
;
; Loop through the tiles and set the following arrays:
;
; grid_fn_all_tiles:
; Full path to the grid file corresponding to each tile.  Note that the
; grid file contains information (coordinates, etc) on the supergrid of
; a given tile, where the supergrid is a grid having twice the resolution 
; of the actual (i.e. computational) grid.
;
; remove_halo_all_tiles:
; Logical array that specifies whether the halo cells around a given tile 
; should be removed before plotting or other processing.
;
; nhSG_all_tiles:
; Halo width on the supergrid of each tile, in units of supergrid cells.
; Normally, only tile 7 of a regional or nexted grid has a halo, so this
; will be zero for tiles 1 through 6.
;
; nxhSG_all_tiles, nyhSG_all_tiles:
; Number of cells, including the halo, in the x and y directions, 
; respectively, on the supergrid of each tile.
;
; nxSG_all_tiles, nySG_all_tiles:
; Number of cells, excluding the halo, in the x and y directions, 
; respectively, on the supergrid of each tile.
;
; nh_all_tiles:
; Halo width on the computational grid of each tile, in units of grid 
; cells.  Normally, only tile 7 of a regional or nexted grid has a halo,
; so this will be zero for tiles 1 through 6.
;
; nxh_all_tiles, nyh_all_tiles:
; Number of cells, including the halo, in the x and y directions, 
; respectively, on the computational grid of each tile.
;
; nx_all_tiles, ny_all_tiles:
; Number of cells, excluding the halo, in the x and y directions, 
; respectively, on the computational grid of each tile.
;
; coord_data_type_all_tiles:
; The data type of the coordinate arrays in the grid file corresponding
; to each tile. 
;
; **********************************************************************
;
  num_tiles_to_plot = dimsizes(tile_inds)

  grid_fn_all_tiles := new((/ num_tiles_to_plot /), "string")

  remove_halo_all_tiles := new((/ num_tiles_to_plot /), "logical")

  nhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nyhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nySG_all_tiles := new((/ num_tiles_to_plot /), "integer")

  nh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nyh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nx_all_tiles := new((/ num_tiles_to_plot /), "integer")
  ny_all_tiles := new((/ num_tiles_to_plot /), "integer")

  coord_data_type_all_tiles := new((/ num_tiles_to_plot /), "string")

  print("")
  print("" + separator_line)
  print("Setting grid file name and dimensions of each specified tile ...")

  do nn=0, num_tiles_to_plot-1

    print("")
    msg := "nn = " + nn
    print("" + msg)
    underline = repeat_str("-", strlen(msg))
    print("" + underline)

    n_tile = tile_inds(nn)
    print("")
    print("  n_tile = " + n_tile)
;
; **********************************************************************
;
; Set the file name (including path) for the current tile.  Then save the 
; result in the grid_fn_all_tiles array for later use.
;
; **********************************************************************
;
; Maybe read in the new parameter DOT_OR_USCORE from the var_defns.sh file.
    grid_fn = cres + "_grid.tile" + n_tile
;    grid_fn = cres + ".grid.tile" + n_tile
    if (strcmp_exact(gtype, "regional") .and. (n_tile .eq. 7)) then
      grid_fn = grid_fn + ".halo" + tostring(nhalo_T7) + ".nc"
    else
      grid_fn = grid_fn + ".nc"
    end if
;    grid_fn = expt_dir + "/fix_sar/" + grid_fn
    grid_fn = expt_dir + "/fix_lam/" + grid_fn

    grid_fn_all_tiles(nn) = grid_fn
    print("  grid_fn_all_tiles(" + nn + ") = " + \
          char_dq + grid_fn_all_tiles(nn) + char_dq)
;
; **********************************************************************
;
; Open the NetCDF file containing the grid specification for the current 
; tile.
;
; **********************************************************************
;
    fp = addfile(grid_fn_all_tiles(nn), "r")
;
; **********************************************************************
;
; Set the halo width (in units of cells).  Note that this is zero unless
; we're on a regional or nested grid and and the current tile is tile 7
; (the regional or nested domain/grid).  Also, set the logical variable
; that determines whether the halo should be removed from the current 
; tile before any processing is performed.  This is set to True only if
; we're on tile 7 of a regional or nested grid and remove_rgnl_halo is
; set to True.
;
; **********************************************************************
;
    nhSG_all_tiles(nn) = 0
    remove_halo_all_tiles(nn) = False

    if ((strcmp_exact(gtype, "regional") .or. \
         strcmp_exact(gtype, "nest")) .and. \
        (n_tile .eq. 7)) then

      nhSG_all_tiles(nn) = 2*nhalo_T7
      if (remove_rgnl_halo) then
        remove_halo_all_tiles(nn) = True
      end if

    end if

    nh_all_tiles(nn) = nhSG_all_tiles(nn)/2
;
; **********************************************************************
;
; Read in the dimensions of the tile's supergrid (which has twice the 
; resolution as the tile's grid).  From these, calculate the dimensions
; of the supergrid.
;
; **********************************************************************
;
    tile_SG_dims := getfilevardimsizes(fp, "area") 

    nxhSG_all_tiles(nn) = tile_SG_dims(1)
    nyhSG_all_tiles(nn) = tile_SG_dims(0)
    nxSG_all_tiles(nn) = nxhSG_all_tiles(nn) - 2*nhSG_all_tiles(nn)
    nySG_all_tiles(nn) = nyhSG_all_tiles(nn) - 2*nhSG_all_tiles(nn)

    print("")
    print("  nhSG_all_tiles(" + nn + ") = " + nhSG_all_tiles(nn))
    print("  nxhSG_all_tiles(" + nn + ") = " + nxhSG_all_tiles(nn))
    print("  nyhSG_all_tiles(" + nn + ") = " + nyhSG_all_tiles(nn))
    print("  nxSG_all_tiles(" + nn + ") = " + nxSG_all_tiles(nn))
    print("  nySG_all_tiles(" + nn + ") = " + nySG_all_tiles(nn))
;
; **********************************************************************
;
; Calculate the dimensions of the computational grid.
;
; **********************************************************************
;
    nxh_all_tiles(nn) = nxhSG_all_tiles(nn)/2
    nyh_all_tiles(nn) = nyhSG_all_tiles(nn)/2
    nx_all_tiles(nn) = nxh_all_tiles(nn) - 2*nh_all_tiles(nn)
    ny_all_tiles(nn) = nyh_all_tiles(nn) - 2*nh_all_tiles(nn)

    print("")
    print("  nh_all_tiles(" + nn + ") = " + nh_all_tiles(nn))
    print("  nxh_all_tiles(" + nn + ") = " + nxh_all_tiles(nn))
    print("  nyh_all_tiles(" + nn + ") = " + nyh_all_tiles(nn))
    print("  nx_all_tiles(" + nn + ") = " + nx_all_tiles(nn))
    print("  ny_all_tiles(" + nn + ") = " + ny_all_tiles(nn))
;
; **********************************************************************
;
; Get the data type of the x coordinate in the grid specification file.
; We assume here that the x and y coordinates have the same data type.
;
; **********************************************************************
;
    coord_data_type_all_tiles(nn) = getfilevartypes(fp, "x") 

    print("")
    print("  coord_data_type_all_tiles(" + nn + ") = " + \
          char_dq + coord_data_type_all_tiles(nn) + char_dq)

  end do

  print("")
  print("Done setting grid file name and dimensions of each specified tile.")
  print("" + separator_line)
;
; **********************************************************************
;
; Compare the coordinate data types of all tiles.  For simplicity, we
; will require that all tiles have the same coordinate data type.  If 
; this is not the case, print out an error message and exit.
;
; **********************************************************************
;
  coord_data_type := coord_data_type_all_tiles(0)

  if (num_tiles_to_plot .gt. 1) then

    match_found \
    := strcmp_exact( \
       coord_data_type_all_tiles(1:num_tiles_to_plot-1), \
       coord_data_type)
    match_by_elem = match_found@match_by_elem

    if (.not. all(match_by_elem)) then

      msg := "  coord_data_type_all_tiles(" \
           + ispan(0, num_tiles_to_plot-1, 1) \
           + ") = " + char_dq + coord_data_type_all_tiles + char_dq
      msg := str_join(msg, char_nl)

      msg := char_nl + \
"For simplicity, we require that the coordinate arrays in the files " + char_nl + \
"corresponding to the specified tiles all have the same data type.  In " + char_nl + \
"this case, they are not:" + char_nl + \
msg + char_nl + \
"Stopping."

      print("" + msg)
      exit

    end if

  end if

  msg := char_nl + \
"The data type of the coordinates in the grid specification files for " + char_nl + \
"all tiles is:" + char_nl + \
"  coord_data_type = " + char_dq + coord_data_type + char_dq
  print("" + msg)
;
; **********************************************************************
;
; Initialize the arrays that will contain the grid and boundary coordinates 
; of all specified tiles to 1-element arrays containing missing values 
; of type coord_data_type.  After the coordinates are appended to these 
; arrays in the loop below, the first elements of these arrays will be 
; stripped away (since they are created here only to make it convenient 
; to append to the arrays).
;
; **********************************************************************
;
  lon_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lat_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lon_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lat_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lon_bdy_all_tiles := new(1, coord_data_type)
  lat_bdy_all_tiles := new(1, coord_data_type)

  lon_halo_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lat_halo_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lon_halo_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lat_halo_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lon_halo_bdy_all_tiles := new(1, coord_data_type)
  lat_halo_bdy_all_tiles := new(1, coord_data_type)
;
; **********************************************************************
;
; Initialize the arrays that will contain the coorinates of the tile 
; centers and the tile corners and midpoints to missing values of type
; coord_data_type.
;
; **********************************************************************
;
  lon_tile_cntr_all_tiles := new((/ num_tiles_to_plot /), coord_data_type)
  lat_tile_cntr_all_tiles := new((/ num_tiles_to_plot /), coord_data_type)

  lon_tile_corners_face_midpts_all_tiles \
  := new((/ num_tiles_to_plot, 8 /), coord_data_type)
  lat_tile_corners_face_midpts_all_tiles \
  := new((/ num_tiles_to_plot, 8 /), coord_data_type)
;
; **********************************************************************
;
; Loop through the specified tiles and read in and process coordinate 
; arrays.
;
; **********************************************************************
;
  print("")
  print("" + separator_line)
  print("Reading in grid coordinates of each specified tile from file ...")

  do nn=0, num_tiles_to_plot-1

    n_tile = tile_inds(nn)
    print("")
    print("  n_tile = " + n_tile)
;
; **********************************************************************
;
; Get grid dimensions of current tile.
;
; **********************************************************************
;
    nhSG = nhSG_all_tiles(nn)
    nxhSG = nxhSG_all_tiles(nn)
    nyhSG = nyhSG_all_tiles(nn)
    nxSG = nxSG_all_tiles(nn)
    nySG = nySG_all_tiles(nn)

    nh = nh_all_tiles(nn)
    nxh = nxh_all_tiles(nn)
    nyh = nyh_all_tiles(nn)
    nx = nx_all_tiles(nn)
    ny = ny_all_tiles(nn)

    remove_halo = remove_halo_all_tiles(nn)
;
; **********************************************************************
;
; Open the NetCDF file containing the grid specification for the current 
; tile.
;
; **********************************************************************
;
    fp = addfile(grid_fn_all_tiles(nn), "r")
;
; **********************************************************************
;
; Read in the supergrid coordinates.  The supergrid of a given tile is a
; grid having twice the resolution of the actual (i.e. computational) 
; grid of that tile.  It is used to store the coordintes of both the 
; centers and the vertices of the cells on the computational grid.
;
; **********************************************************************
; 
    lon_verts_SG_crnt_tile := fp->x(:,:)
    lat_verts_SG_crnt_tile := fp->y(:,:)

    lon_verts_SG_crnt_tile \
    := adjust_longitude_range(lon_verts_SG_crnt_tile, -180.0d+0, "degs")
;
; **********************************************************************
;
; Get the coordinates of the cell vertices on the current tile from those 
; of the supergrid.
;
; **********************************************************************
;
    lon_verts_crnt_tile := lon_verts_SG_crnt_tile(0::2,0::2)
    lat_verts_crnt_tile := lat_verts_SG_crnt_tile(0::2,0::2)
;
; **********************************************************************
;
; Get the coordinates of the cell centers on the current tile from those
; of the supergrid.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile := lon_verts_SG_crnt_tile(1::2,1::2)
    lat_cntrs_crnt_tile := lat_verts_SG_crnt_tile(1::2,1::2)
;
; **********************************************************************
;
; Set arrays containing the coordinates of just the halo cells (with all
; internal cells' coordinates set to the approprite type of fill value).  
; This approach allows us to more conveniently plot just the halo cells 
; using the same plotting routines as for the internal cells.
;
; **********************************************************************
;
    lon_halo_cntrs_crnt_tile := lon_cntrs_crnt_tile
    lon_halo_cntrs_crnt_tile(nh:nyh-nh,nh:nxh-nh) \
    = default_fillvalue(coord_data_type)
    lat_halo_cntrs_crnt_tile := lat_cntrs_crnt_tile
    lat_halo_cntrs_crnt_tile(nh:nyh-nh,nh:nxh-nh) \
    = default_fillvalue(coord_data_type)

    lon_halo_verts_crnt_tile := lon_verts_crnt_tile
    lon_halo_verts_crnt_tile(nh+1:nyh-nh-1,nh+1:nxh-nh-1) \
    = default_fillvalue(coord_data_type)
    lat_halo_verts_crnt_tile := lat_verts_crnt_tile
    lat_halo_verts_crnt_tile(nh+1:nyh-nh-1,nh+1:nxh-nh-1) \
    = default_fillvalue(coord_data_type)
;
; **********************************************************************
;
; If on a regional grid, if the current tile is tile 7 (the regional 
; domain/grid), and if remove_rgnl_halo is set to True, then remove a 
; halo of width nhalo_T7 cells from each of the coordinate arrays.
;
; **********************************************************************
;
    if (remove_halo) then

      print("")
      print("  Removing halo cells from coordinate arrays of tile " + \
            n_tile + " ...")
;
; **********************************************************************
;
; Remove halo cells from the arrays containing coordinates of the cell
; vertices of the supergrid.
;
; **********************************************************************
;
      lon_verts_SG_crnt_tile \
      := lon_verts_SG_crnt_tile(nhSG:nyhSG-nhSG, nhSG:nxhSG-nhSG)
      lat_verts_SG_crnt_tile \
      := lat_verts_SG_crnt_tile(nhSG:nyhSG-nhSG, nhSG:nxhSG-nhSG)
;
; **********************************************************************
;
; Remove halo cells from the arrays containing the coordinates of cell
; centers of the computational grid.
;
; **********************************************************************
;
      lon_cntrs_crnt_tile \
      := lon_cntrs_crnt_tile(nh:nyh-1-nh, nh:nxh-1-nh)
      lat_cntrs_crnt_tile \
      := lat_cntrs_crnt_tile(nh:nyh-1-nh, nh:nxh-1-nh)
;
; **********************************************************************
;
; Remove halo cells from the arrays containing coordinates of the cell
; vertices of the computational grid.
;
; **********************************************************************
;
      lon_verts_crnt_tile := lon_verts_crnt_tile(nh:nyh-nh, nh:nxh-nh)
      lat_verts_crnt_tile := lat_verts_crnt_tile(nh:nyh-nh, nh:nxh-nh)

      print("  Done removing halo cells from coordinate arrays of " + \
            "tile " + n_tile + ".")

    end if
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the center of each cell on the current tile.  Note that these are 1-D
; arrays, and their size (i.e. the number of elements they contain) is 
; equal to the number of cells on the current tile's grid (i.e. nxh*nyh
; or nx*ny).  This unstructured format is useful for generating color-
; contour plots of fields on the grid that have one value per cell 
; represented by a flat color in that cell.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile_unstruc := ndtooned(lon_cntrs_crnt_tile)
    lat_cntrs_crnt_tile_unstruc := ndtooned(lat_cntrs_crnt_tile)

    lon_halo_cntrs_crnt_tile_unstruc := ndtooned(lon_halo_cntrs_crnt_tile)
    lat_halo_cntrs_crnt_tile_unstruc := ndtooned(lat_halo_cntrs_crnt_tile)
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the vertices of each cell on the current tile.  Note that these are 
; 2-D arrays whose first dimension size is the number of cells on the 
; current tile's grid (i.e. nxh*nyh or nx*ny) and whose second dimension
; size is 4 (since each cell has 4 vertices).  This unstructured format
; is useful for generating color-contour plots of fields on the grid 
; that have one value per cell represented by a flat color in that cell.
;
; **********************************************************************
;

; Get dimensions again because they depend on whether the halo is being 
; removed or not (remove_rgnl_halo).
    dims := dimsizes(lon_cntrs_crnt_tile)
    endx := dims(1)
    endy := dims(0)

    lon_verts_crnt_tile_unstruc \
    := (/ ndtooned(lon_verts_crnt_tile(0:endy-1,0:endx-1)), \
          ndtooned(lon_verts_crnt_tile(0:endy-1,1:endx)), \
          ndtooned(lon_verts_crnt_tile(1:endy,1:endx)), \
          ndtooned(lon_verts_crnt_tile(1:endy,0:endx-1)) /)
    lon_verts_crnt_tile_unstruc \
    := transpose(lon_verts_crnt_tile_unstruc)

    lat_verts_crnt_tile_unstruc \
    := (/ ndtooned(lat_verts_crnt_tile(0:endy-1,0:endx-1)), \
          ndtooned(lat_verts_crnt_tile(0:endy-1,1:endx)), \
          ndtooned(lat_verts_crnt_tile(1:endy,1:endx)), \
          ndtooned(lat_verts_crnt_tile(1:endy,0:endx-1)) /)
    lat_verts_crnt_tile_unstruc \
    := transpose(lat_verts_crnt_tile_unstruc)


; Do same for halo coordinates.
    lon_halo_verts_crnt_tile_unstruc \
    := (/ ndtooned(lon_halo_verts_crnt_tile(0:nyh-1,0:nxh-1)), \
          ndtooned(lon_halo_verts_crnt_tile(0:nyh-1,1:nxh)), \
          ndtooned(lon_halo_verts_crnt_tile(1:nyh,1:nxh)), \
          ndtooned(lon_halo_verts_crnt_tile(1:nyh,0:nxh-1)) /)
    lon_halo_verts_crnt_tile_unstruc \
    := transpose(lon_halo_verts_crnt_tile_unstruc)

    lat_halo_verts_crnt_tile_unstruc \
    := (/ ndtooned(lat_halo_verts_crnt_tile(0:nyh-1,0:nxh-1)), \
          ndtooned(lat_halo_verts_crnt_tile(0:nyh-1,1:nxh)), \
          ndtooned(lat_halo_verts_crnt_tile(1:nyh,1:nxh)), \
          ndtooned(lat_halo_verts_crnt_tile(1:nyh,0:nxh-1)) /)
    lat_halo_verts_crnt_tile_unstruc \
    := transpose(lat_halo_verts_crnt_tile_unstruc)

    do i=0, nxh-1
      do j=0, nyh-1
        if ((i .ge. nh) .and. (i .le. nxh-nh-1)) .and. \
           ((j .ge. nh) .and. (j .le. nyh-nh-1)) then 
          indx = i + j*nxh
          lon_halo_verts_crnt_tile_unstruc(indx,:) = default_fillvalue(coord_data_type)
          lat_halo_verts_crnt_tile_unstruc(indx,:) = default_fillvalue(coord_data_type)
        end if
      end do
    end do
;
; **********************************************************************
;
; Append to the unstructured arrays that will contain the coordinates of
; the cell centers and cell vertices on all specified tiles.  We refer 
; to these as the "all-tiles" arrays.
;
; **********************************************************************
;
    lon_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lon_cntrs_all_tiles_unstruc, lon_cntrs_crnt_tile_unstruc, 0)
    lat_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lat_cntrs_all_tiles_unstruc, lat_cntrs_crnt_tile_unstruc, 0)

    lon_verts_all_tiles_unstruc \
    := array_append_record( \
       lon_verts_all_tiles_unstruc, lon_verts_crnt_tile_unstruc, 0)
    lat_verts_all_tiles_unstruc \
    := array_append_record( \
       lat_verts_all_tiles_unstruc, lat_verts_crnt_tile_unstruc, 0)

    lon_halo_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lon_halo_cntrs_all_tiles_unstruc, lon_halo_cntrs_crnt_tile_unstruc, 0)
    lat_halo_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lat_halo_cntrs_all_tiles_unstruc, lat_halo_cntrs_crnt_tile_unstruc, 0)

    lon_halo_verts_all_tiles_unstruc \
    := array_append_record( \
       lon_halo_verts_all_tiles_unstruc, lon_halo_verts_crnt_tile_unstruc, 0)
    lat_halo_verts_all_tiles_unstruc \
    := array_append_record( \
       lat_halo_verts_all_tiles_unstruc, lat_halo_verts_crnt_tile_unstruc, 0)
;
; **********************************************************************
;
; If get_tile_bdies is True, generate unstructured boundary coordinate
; arrays.
;
; **********************************************************************
;
    if (get_tile_bdies) then
;
; First, get the coordinates of the boundary points on the current tile.
; Here, by "boundary points", we mean those cell vertices that happen to
; lie on the tile's boundary.
;
      repeat_last_point = True
      array_order = "ji"
      bdy_info := get_rect_grid_bdy( \
                  lon_verts_crnt_tile, lat_verts_crnt_tile, \
                  repeat_last_point, array_order)
      lon_bdy_crnt_tile := bdy_info@x_bdy
      lat_bdy_crnt_tile := bdy_info@y_bdy
;
; Append to the arrays that will contain the coordinates of the boundary
; points on all specified tiles.  We refer to these as the "all-tiles" 
; arrays.
;
      lon_bdy_all_tiles \
      := array_append_record(lon_bdy_all_tiles, lon_bdy_crnt_tile, 0)
      lat_bdy_all_tiles \
      := array_append_record(lat_bdy_all_tiles, lat_bdy_crnt_tile, 0)


; Do same for halo coordinates.
;
; First, get the coordinates of the boundary points on the current tile.
; Here, by "boundary points", we mean those cell vertices that happen to
; lie on the tile's boundary.
;
      repeat_last_point = True
      array_order = "ji"
      bdy_info := get_rect_grid_bdy( \
                  lon_halo_verts_crnt_tile, lat_halo_verts_crnt_tile, \
                  repeat_last_point, array_order)
      lon_halo_bdy_crnt_tile := bdy_info@x_bdy
      lat_halo_bdy_crnt_tile := bdy_info@y_bdy
;
; Append to the arrays that will contain the coordinates of the boundary
; points on all specified tiles.  We refer to these as the "all-tiles" 
; arrays.
;
      lon_halo_bdy_all_tiles \
      := array_append_record(lon_halo_bdy_all_tiles, lon_halo_bdy_crnt_tile, 0)
      lat_halo_bdy_all_tiles \
      := array_append_record(lat_halo_bdy_all_tiles, lat_halo_bdy_crnt_tile, 0)

    end if
;
; **********************************************************************
;
; Find and print out the coordinates of the corners of the current tile.
;
; **********************************************************************
;
    x_is_longitude = True
    opts := True
    opts@verbose = False
    corner_info := get_rect_grid_corners( \
                   lon_verts_crnt_tile, lat_verts_crnt_tile, \
                   "deg", "deg", x_is_longitude, opts)
    corner_lons := corner_info@x_corners
    corner_lats := corner_info@y_corners

    print("")
    print("  Tile corner lon/lat coordinates are:")
    fmt_str = "%7.2f"
    do c=0, dimsizes(corner_lons)-1
      lon_str = sprintf(fmt_str, corner_lons(c))
      lat_str = sprintf(fmt_str, corner_lats(c))
      print("    Corner " + (c+1) + ":  lon = " + lon_str + " deg;  " + \
            "lat = " + lat_str + " deg")
    end do
;
; **********************************************************************
;
; Set the i-indices of the domain's left (west) boundary, center, and 
; right (east) boundary and the j-indices of the bottom (south) boundary, 
; middle (center), and top (north) boundary in the arrays containing the 
; coordinates of the supergrid.
;
; **********************************************************************
;
    if (remove_halo) then

      i_left = 0
      i_cntr = nxSG/2
      i_rght = nxSG

      j_bot = 0
      j_mid = nySG/2
      j_top = nySG

    else

      i_left = 0
      i_cntr = nxhSG/2
      i_rght = nxhSG

      j_bot = 0
      j_mid = nyhSG/2
      j_top = nyhSG

    end if
;
; **********************************************************************
;
; Check whether any of the four faces of the current tile cross the 
; international date line (IDL).  This is important because if so, we 
; will not be able to identify the southwest (SW), southeast (SE), 
; northwest (NW), and northeast (NE) corners of the tile.  We perform 
; this check for each face by checking whether there is a jump in the 
; longitudes of grid cell corner points that lie on the face as we move 
; along the face.
;
; Note that if one (or both) of the poles lies within the tile, then one
; of the tile faces must cross the IDL.  Thus, the IDL crossing check 
; below will be triggered if one or both poles lie within the tile, but
; the triggering of this check does not necessarily imply that one or 
; both poles lie within the tile (i.e. crossing of the IDL by a tile
; boundary is a necessary but not sufficient condition for one or both
; poles to lie within the tile).  Below, if the IDL crossing check is
; triggered, we do not go further to check whether or not one or both 
; poles lie within the tile (because that test is more complex).
;
; **********************************************************************
;
    face_id_strs := (/ "bottom", "right", "top", "left" /)
    num_faces := dimsizes(face_id_strs)
if (False) then
;    abs_dlon_cutoff := 0.0d+0  ; For debugging only.
    abs_dlon_cutoff := 180.0d+0

    fmt_str = "%8.4f"
    abs_dlon_cutoff_str = sprintf(fmt_str, abs_dlon_cutoff)

    face_id_strs := (/ "bottom", "right", "top", "left" /)
    num_faces := dimsizes(face_id_strs)
    do i=0, num_faces-1

      face_id_str := face_id_strs(i)
      if (strcmp_exact(face_id_str, "bottom")) then
        lon_crnt_face := lon_verts_SG_crnt_tile(j_bot,:)
      else if (strcmp_exact(face_id_str, "right")) then
        lon_crnt_face := lon_verts_SG_crnt_tile(:,i_rght)
      else if (strcmp_exact(face_id_str, "top")) then
        lon_crnt_face := lon_verts_SG_crnt_tile(j_top,:)
      else if (strcmp_exact(face_id_str, "left")) then
        lon_crnt_face := lon_verts_SG_crnt_tile(:,i_left)
      end if
      end if
      end if
      end if

      num_face_pts := dimsizes(lon_crnt_face)
      dlon := lon_crnt_face(1:num_face_pts-1) - lon_crnt_face(0:num_face_pts-2)
      abs_dlon_max := max(abs(dlon))

      if (abs_dlon_max .ge. abs_dlon_cutoff) then
        abs_dlon_max_str = sprintf(fmt_str, abs_dlon_max)
        lat_str = sprintf(fmt_str, abs_dlon_max)
        msg := char_nl + \
"The " + char_dq + face_id_str + char_dq + " boundary of the current tile " + \
"crosses the international date " + char_nl + \
"line (IDL) because there is a jump in longitude (abs_dlon_max) from one " + char_nl + \
"grid point to the next along that boundary with a magnitude that is greater " + char_nl + \
"than or equal to the maximum allowed value specified by " + char_dq + "abs_dlon_cutoff" + char_dq + ":" + char_nl + \
"  abs_dlon_max    = " + abs_dlon_max_str + " deg" + char_nl + \
"  abs_dlon_cutoff = " + abs_dlon_cutoff_str + " deg" + char_nl + \
"Please express the longitude and latitude of the grid points in a rotated" + char_nl + \
"lat/lon coordinate system to avoid this problem." + char_nl + \
"Stopping."
        print("" + msg)
        exit
      end if

    end do
end if
;
; **********************************************************************
;
; Save in lon_tile_corners_crnt_tile and lat_tile_corners_crnt_tile the
; longitudes and latitudes of the four corners of the current tile, 
; starting with the lower left corner and proceeding counterclockwise to
; the upper right corner.
;
; **********************************************************************
;
    num_corners := 4
    lon_tile_corners_crnt_tile := new((/ num_corners /), coord_data_type)
    lat_tile_corners_crnt_tile := new((/ num_corners /), coord_data_type)

    i = 0
    lon_tile_corners_crnt_tile(i) \
    = lon_verts_SG_crnt_tile(j_bot, i_left)
    lat_tile_corners_crnt_tile(i) \
    = lat_verts_SG_crnt_tile(j_bot, i_left)

    i = i + 1
    lon_tile_corners_crnt_tile(i) \
    = lon_verts_SG_crnt_tile(j_bot, i_rght)
    lat_tile_corners_crnt_tile(i) \
    = lat_verts_SG_crnt_tile(j_bot, i_rght)

    i = i + 1
    lon_tile_corners_crnt_tile(i) \
    = lon_verts_SG_crnt_tile(j_top, i_rght)
    lat_tile_corners_crnt_tile(i) \
    = lat_verts_SG_crnt_tile(j_top, i_rght)

    i = i + 1
    lon_tile_corners_crnt_tile(i) \
    = lon_verts_SG_crnt_tile(j_top, i_left)
    lat_tile_corners_crnt_tile(i) \
    = lat_verts_SG_crnt_tile(j_top, i_left)
;
; **********************************************************************
;
; Save in lon_face_midpts_crnt_tile and lat_face_midpts_crnt_tile the
; longitudes and latitudes of the midpoints of the four faces of the 
; current tile, starting with the bottom face and proceeding counterclockwise 
; to the left face.
;
; **********************************************************************
;
;    num_faces := 4
    lon_face_midpts_crnt_tile := new((/ num_faces /), coord_data_type)
    lat_face_midpts_crnt_tile := new((/ num_faces /), coord_data_type)

    i = 0
    lon_face_midpts_crnt_tile(i) = lon_verts_SG_crnt_tile(j_bot, i_cntr)
    lat_face_midpts_crnt_tile(i) = lat_verts_SG_crnt_tile(j_bot, i_cntr)

    i = i + 1
    lon_face_midpts_crnt_tile(i) = lon_verts_SG_crnt_tile(j_mid, i_rght)
    lat_face_midpts_crnt_tile(i) = lat_verts_SG_crnt_tile(j_mid, i_rght)

    i = i + 1
    lon_face_midpts_crnt_tile(i) = lon_verts_SG_crnt_tile(j_top, i_cntr)
    lat_face_midpts_crnt_tile(i) = lat_verts_SG_crnt_tile(j_top, i_cntr)

    i = i + 1
    lon_face_midpts_crnt_tile(i) = lon_verts_SG_crnt_tile(j_mid, i_left)
    lat_face_midpts_crnt_tile(i) = lat_verts_SG_crnt_tile(j_mid, i_left)
;
; **********************************************************************
;
; Now find the indices into lon_tile_corners_crnt_tile (or 
; lat_tile_corners_crnt_tile) of the southwest, southeast, northeast, 
; and northwest corners of the current tile.
;
; **********************************************************************
;
    indx_SW := new(1, "integer")
    indx_SE := new(1, "integer")
    indx_NE := new(1, "integer")
    indx_NW := new(1, "integer")

    do i=0, num_corners-1

      ip1 = i + 1
      if (ip1 .gt. num_corners-1) then 
        ip1 = 0
      end if

      ip2 = ip1 + 1
      if (ip2 .gt. num_corners-1) then 
        ip2 = 0
      end if

      ip3 = ip2 + 1
      if (ip3 .gt. num_corners-1) then 
        ip3 = 0
      end if

      lon_i := lon_tile_corners_crnt_tile(i)
      lat_i := lat_tile_corners_crnt_tile(i)
    
      lon_ip1 := lon_tile_corners_crnt_tile(ip1)
      lat_ip1 := lat_tile_corners_crnt_tile(ip1)

      lon_ip2 := lon_tile_corners_crnt_tile(ip2)
      lat_ip2 := lat_tile_corners_crnt_tile(ip2)

      lon_ip3 := lon_tile_corners_crnt_tile(ip3)
      lat_ip3 := lat_tile_corners_crnt_tile(ip3)

      if (ismissing(indx_SW) .and. \
          (lon_i .lt. lon_ip1) .and. \
          (lon_i .lt. lon_ip2) .and. \
          (lat_i .lt. lat_ip2) .and. \
          (lat_i .lt. lat_ip3)) then
         indx_SW = i
      end if

      if (ismissing(indx_SE) .and. \
          (lon_i .gt. lon_ip2) .and. \
          (lon_i .gt. lon_ip3) .and. \
          (lat_i .lt. lat_ip1) .and. \
          (lat_i .lt. lat_ip2)) then
         indx_SE := i
      end if

      if (ismissing(indx_NE) .and. \
          (lon_i .gt. lon_ip1) .and. \
          (lon_i .gt. lon_ip2) .and. \
          (lat_i .gt. lat_ip2) .and. \
          (lat_i .gt. lat_ip3)) then
         indx_NE := i
      end if

      if (ismissing(indx_NW) .and. \
          (lon_i .lt. lon_ip2) .and. \
          (lon_i .lt. lon_ip3) .and. \
          (lat_i .gt. lat_ip1) .and. \
          (lat_i .gt. lat_ip2)) then
         indx_NW := i
      end if

    end do

indx_SW := (/ 0 /)
indx_SE := (/ 1 /)
indx_NE := (/ 2 /)
indx_NW := (/ 3 /)
;
; **********************************************************************
;
; Now rearrange the lon_tile_corners_crnt_tile and lat_tile_corners_crnt_tile 
; arrays so that the first element corresponds to the southwest corner of 
; the tile, the second corresponds to the southeast corner, the third 
; corresponds to the northeast corner, and the fourth corresponds to the 
; northwest corner.  Also, rearange the lon_face_midpts_crnt_tile and 
; lat_face_midpts_crnt_tile arrays so that the first element corresponds 
; to the southern face, the second corresponds to the eastern face, the 
; third corresponds to the northern face, and the fourth corresponds to 
; the western face.
;
; **********************************************************************
;
; IMPORTANT NOTE:
; For a global cubed-sphere grid, for three of the tiles (the ones over 
; the north and south poles and the one that straddles the IDL), the 
; indices of the SW, SE, NE, and NW corners of the tile will not be set 
; (they will remain set to their initial missing values), so the check
; below will be triggered.  Something more complex needs to be done for
; such tiles, but we do not worry about it here for now since we're only
; dealing with regional domains.
;
    inds_reorder := (/ indx_SW, indx_SE, indx_NE, indx_NW /)
    if (any(ismissing(inds_reorder))) then
      msg := char_nl + \
"One or more of the indices for the SW, SE, NE, and NW corners of the " + char_nl + \
"current tile have not been set:" + char_nl + \
"  indx_SW = " + indx_SW + char_nl + \
"  indx_SE = " + indx_SE + char_nl + \
"  indx_NE = " + indx_NE + char_nl + \
"  indx_NW = " + indx_NW + char_nl + \
"Stopping."
      print("" + msg)
      exit
    end if

    lon_tile_corners_crnt_tile := lon_tile_corners_crnt_tile(inds_reorder)
    lat_tile_corners_crnt_tile := lat_tile_corners_crnt_tile(inds_reorder)

    lon_face_midpts_crnt_tile := lon_face_midpts_crnt_tile(inds_reorder)
    lat_face_midpts_crnt_tile := lat_face_midpts_crnt_tile(inds_reorder)
;
; **********************************************************************
;
; Now save the reordered tile corner and tile face midpoint coordinate
; arrays for the current tile in the arrays containing the coordinates
; for all tiles.
;
; **********************************************************************
;
    inds = (/ 0, 2, 4, 6 /)

    lon_tile_corners_face_midpts_all_tiles(nn,inds) \
    = lon_tile_corners_crnt_tile
    lon_tile_corners_face_midpts_all_tiles(nn,inds+1) \
    = lon_face_midpts_crnt_tile

    lat_tile_corners_face_midpts_all_tiles(nn,inds) \
    = lat_tile_corners_crnt_tile
    lat_tile_corners_face_midpts_all_tiles(nn,inds+1) \
    = lat_face_midpts_crnt_tile
;
; **********************************************************************
;
; Calculate the coordinates of the center of the current tile as well as
; the coordinates of the tile corners and the midpoints of the four tile
; faces.
;
; **********************************************************************
;
    lon_tile_cntr_all_tiles(nn) = lon_verts_SG_crnt_tile(j_mid, i_cntr)
    lat_tile_cntr_all_tiles(nn) = lat_verts_SG_crnt_tile(j_mid, i_cntr)
;
; **********************************************************************
;
; Print out the coordinates of tile corners and tile face midpoints.
;
; **********************************************************************
;
    lon_str := sprintf("%10.6f", lon_tile_corners_face_midpts_all_tiles(nn,:))
    lat_str := sprintf("%10.6f", lat_tile_corners_face_midpts_all_tiles(nn,:))

    loc_names := (/ "SW_corner", "S_face_midpt", \
                    "SE_corner", "E_face_midpt", \
                    "NE_corner", "N_face_midpt", \
                    "NW_corner", "W_face_midpt" /)
    loc_names := strpad(loc_names + ":", " ", "right")
    lon_str := strpad(lon_str + " deg", " ", "left")
    lat_str := strpad(lat_str + " deg", " ", "left")
    msg := loc_names + "  lon = " + lon_str + ";  lat = " + lat_str
    msg := "  " + msg
    msg := array_append_record( \
           (/ \
"Longitudes and latitudes of the corners and face midpoints of tile #" + n_tile, \
"are:" \
           /), msg, 0)
    msg := "  " + msg
    msg := str_join(msg, char_nl)
    print("")
    print("" + msg)
  end do

  print("")
  print("Done reading in grid coordinates of each specified tile.")
  print("" + separator_line)
;
; **********************************************************************
;
; Remove the first elements in the unstructured arrays containing the
; coordinates of the grid cells and tile boundaries.  Recall that these
; first elements were defined to make it convenient to append the coordinates 
; of each consecutive tile; they contain missing values of type coord_data_type.
;
; **********************************************************************
;
  lon_cntrs_all_tiles_unstruc := lon_cntrs_all_tiles_unstruc(1:)
  lat_cntrs_all_tiles_unstruc := lat_cntrs_all_tiles_unstruc(1:)
  lon_verts_all_tiles_unstruc := lon_verts_all_tiles_unstruc(1:,:)
  lat_verts_all_tiles_unstruc := lat_verts_all_tiles_unstruc(1:,:)

  lon_halo_cntrs_all_tiles_unstruc := lon_halo_cntrs_all_tiles_unstruc(1:)
  lat_halo_cntrs_all_tiles_unstruc := lat_halo_cntrs_all_tiles_unstruc(1:)
  lon_halo_verts_all_tiles_unstruc := lon_halo_verts_all_tiles_unstruc(1:,:)
  lat_halo_verts_all_tiles_unstruc := lat_halo_verts_all_tiles_unstruc(1:,:)

  if (get_tile_bdies) then
    lon_bdy_all_tiles := lon_bdy_all_tiles(1:)
    lat_bdy_all_tiles := lat_bdy_all_tiles(1:)
    lon_halo_bdy_all_tiles := lon_halo_bdy_all_tiles(1:)
    lat_halo_bdy_all_tiles := lat_halo_bdy_all_tiles(1:)
  end if
;
; **********************************************************************
;
; Return results as attributes of the logical variable grid_info.
;
; **********************************************************************
;
  grid_info := True

  grid_info@fp = fp
  grid_info@grid_fn_all_tiles = grid_fn_all_tiles

  grid_info@nhSG_all_tiles = nhSG_all_tiles
  grid_info@nxhSG_all_tiles = nxhSG_all_tiles
  grid_info@nyhSG_all_tiles = nyhSG_all_tiles
  grid_info@nxSG_all_tiles = nxSG_all_tiles
  grid_info@nySG_all_tiles = nySG_all_tiles

  grid_info@nh_all_tiles = nh_all_tiles
  grid_info@nxh_all_tiles = nxh_all_tiles
  grid_info@nyh_all_tiles = nyh_all_tiles
  grid_info@nx_all_tiles = nx_all_tiles
  grid_info@ny_all_tiles = ny_all_tiles

  grid_info@remove_halo_all_tiles = remove_halo_all_tiles

  grid_info@lon_cntrs_all_tiles_unstruc = lon_cntrs_all_tiles_unstruc
  grid_info@lat_cntrs_all_tiles_unstruc = lat_cntrs_all_tiles_unstruc
  grid_info@lon_verts_all_tiles_unstruc = lon_verts_all_tiles_unstruc
  grid_info@lat_verts_all_tiles_unstruc = lat_verts_all_tiles_unstruc

  grid_info@lon_bdy_all_tiles = lon_bdy_all_tiles
  grid_info@lat_bdy_all_tiles = lat_bdy_all_tiles

  grid_info@lon_halo_cntrs_all_tiles_unstruc = lon_halo_cntrs_all_tiles_unstruc
  grid_info@lat_halo_cntrs_all_tiles_unstruc = lat_halo_cntrs_all_tiles_unstruc
  grid_info@lon_halo_verts_all_tiles_unstruc = lon_halo_verts_all_tiles_unstruc
  grid_info@lat_halo_verts_all_tiles_unstruc = lat_halo_verts_all_tiles_unstruc

  grid_info@lon_halo_bdy_all_tiles = lon_halo_bdy_all_tiles
  grid_info@lat_halo_bdy_all_tiles = lat_halo_bdy_all_tiles

  grid_info@lon_tile_cntr_all_tiles = lon_tile_cntr_all_tiles
  grid_info@lat_tile_cntr_all_tiles = lat_tile_cntr_all_tiles

  grid_info@lon_tile_corners_face_midpts_all_tiles \
  = lon_tile_corners_face_midpts_all_tiles
  grid_info@lat_tile_corners_face_midpts_all_tiles \
  = lat_tile_corners_face_midpts_all_tiles
 
  grid_info@coord_data_type = coord_data_type

  return(grid_info)

end

