;
; **********************************************************************
;
; File name: read_FV3SAR_grid_native.ncl
; Author: Gerard Ketefian
;
; Description:
; ^^^^^^^^^^^
; This function returns the file names, dimensions, cell center coordi-
; nates, and cell vertex coordinates of the grids associated with the 
; specified FV3 cubed-sphere tiles (tile_inds).  If get_tile_bdies is 
; set to True, it also returns the coordinates of those grid cell verti-
; ces that lie on the boundary of each specified tile.
;
; The input arguments to this function are as follows:
;
; work_dir:
; This is the work directory created by the FV3SAR workflow.  The grid
; specification files corresponding to the cubed-sphere tiles are within
; subdirectories under this directory.
;
; gtype:
; This is a string containing the grid type of the FV3 cubed-sphere grid
; being read in.  For files generated by the FV3SAR workflow, this will
; be equal to "regional".
; 
; cres:
; This is the C-resolution of the global cubed-sphere grid that serves
; as the "parent" of the regional grid.  It consists of the character 
; "C" followed by an interger that is equal to the number of grid cells
; in each of the two horizontal directions (say x and y) on each of the
; six tiles of the parent global grid.  Note that this number is in ge-
; neral not equal to the number of grid cells on the regional grid (i.e.
; the one on tile 7) because the latter is given by the former multi-
; plied by a refinement factor (an integer) that is normally greater 
; than 1.
;
; tile_inds:
; The indices of the tiles (associated with ither the parent global grid
; or the regional grid) to consider in this function.
;
; get_tile_bdies:
; A logical variable that specifies whether arrays containing the coor-
; dinates of grid cell vertices that lie on the boundary of each tile 
; specified in tile_inds are to be extracted and returned.
;
; nhalo_T7:
; The width of the halo (in units of grid cells) included in the grid 
; specification file for the regional grid (tile 7).  If tile_inds in-
; cludes tile 7, then this is used to form the name of the grid file for
; that tile.  Also, if tile_inds includes tile 7 and if remove_rgnl_halo
; is set to True, then a halo of width nhalo_T7 is removed from any ar-
; rays read in from the tile 7 grid file.  This is not used if tile_inds
; does not include tile 7.
;
; remove_rgnl_halo:
; Flag indicating whether to remove a halo of width nhalo_T7 from any
; arrays read in from the tile 7 grid file.  This is not used if tile_-
; inds does not include tile 7.
;
; **********************************************************************
;
loadscript(lib_location + "special_chars.ncl")
loadscript(lib_location + "strcmp_exact.ncl")
loadscript(lib_location + "strpad.ncl")
loadscript(lib_location + "get_rect_grid_bdy.ncl")
loadscript(lib_location + "get_rect_grid_corners.ncl")
loadscript(lib_location + "adjust_longitude_range.ncl")

undef("read_FV3SAR_grid_native")

function read_FV3SAR_grid_native( \
         work_dir:string, \
         gtype:string, \
         cres:string, \
         tile_inds:integer, \
         get_tile_bdies:logical, \
         nhalo_T7:integer, \
         remove_rgnl_halo:logical)

local num_tiles_to_plot, \
\
      grid_fn_all_tiles, remove_halo_all_tiles, \
\
      nhSG_all_tiles, nxhSG_all_tiles, nyhSG_all_tiles, \
      nxSG_all_tiles, nySG_all_tiles, \
      nh_all_tiles, nxh_all_tiles, nyh_all_tiles, \
      nx_all_tiles, ny_all_tiles, \
\
      coord_data_type_all_tiles, \
\
      nn, msg, underline, n_tile, grid_fn, fp, \
      tile_SG_dims, \
\
      coord_data_type, match_found, match_by_elem, \
\
      lon_cntrs_all_tiles_unstruc, lat_cntrs_all_tiles_unstruc, \
      lon_verts_all_tiles_unstruc, lat_verts_all_tiles_unstruc, \
      lon_bdy_all_tiles, lat_bdy_all_tiles, \
\
      lon_tile_cntr_all_tiles, lat_tile_cntr_all_tiles, \
      lon_tile_corners_face_midpts_all_tiles, \
      lat_tile_corners_face_midpts_all_tiles, \
\
      nhSG, nxhSG, nyhSG, nxSG, nySG, \
      nh, nxh, nyh, nx, ny, \
      remove_halo, \
\
      lon_verts_SG_crnt_tile, lat_verts_SG_crnt_tile, \
      lon_verts_crnt_tile, lat_verts_crnt_tile, \
      lon_cntrs_crnt_tile, lat_cntrs_crnt_tile, \
\
      repeat_last_point, array_order, bdy_info, \
      lon_bdy_crnt_tile, lat_bdy_crnt_tile, \
\
      x_is_longitude, opts, corner_info, corner_lons, corner_lats, \
      fmt_str, lon_str, lat_str, \
      i_left, i_cntr, i_rght, j_bot, j_mid, j_top, \
      loc_names, i, \
\
      lon_cntrs_crnt_tile_unstruc, lat_cntrs_crnt_tile_unstruc, \
      lon_verts_crnt_tile_unstruc, lat_verts_crnt_tile_unstruc, \
      lon_cntrs_all_tiles_unstruc, lat_cntrs_all_tiles_unstruc, \
      lon_verts_all_tiles_unstruc, lat_verts_all_tiles_unstruc, \
\
      grid_info

begin
;
; **********************************************************************
;
; If not already defined, define the string separator_line that serves
; as a separator line between different sections of printout.
;
; **********************************************************************
;
  if (.not. isvar("separator_line")) then
    separator_line := repeat_str("=", 72)
  end if
;
; **********************************************************************
;
; Loop through the tiles and set the following arrays:
;
; grid_fn_all_tiles:
; Full path to the grid file corresponding to each tile.  Note that the
; grid file contains information (coordinates, etc) on the supergrid of
; a given tile, where the supergrid is a grid having twice the resolu-
; tion of the actual (i.e. computational) grid.
;
; remove_halo_all_tiles:
; Logical array that specifies whether the halo cells around a given 
; tile should be removed before plotting or other processing.
;
; nhSG_all_tiles:
; Halo width on the supergrid of each tile, in units of supergrid cells.
; Normally, only tile 7 of a regional or nexted grid has a halo, so this
; will be zero for tiles 1 through 6.
;
; nxhSG_all_tiles, nyhSG_all_tiles:
; Number of cells, including the halo, in the x and y directions, res-
; pectively, on the supergrid of each tile.
;
; nxSG_all_tiles, nySG_all_tiles:
; Number of cells, excluding the halo, in the x and y directions, res-
; pectively, on the supergrid of each tile.
;
; nh_all_tiles:
; Halo width on the computational grid of each tile, in units of grid 
; cells.  Normally, only tile 7 of a regional or nexted grid has a halo,
; so this will be zero for tiles 1 through 6.
;
; nxh_all_tiles, nyh_all_tiles:
; Number of cells, including the halo, in the x and y directions, res-
; pectively, on the computational grid of each tile.
;
; nx_all_tiles, ny_all_tiles:
; Number of cells, excluding the halo, in the x and y directions, res-
; pectively, on the computational grid of each tile.
;
; coord_data_type_all_tiles:
; The data type of the coordinate arrays in the grid file corresponding
; to each tile. 
;
; **********************************************************************
;
  num_tiles_to_plot = dimsizes(tile_inds)

  grid_fn_all_tiles := new((/ num_tiles_to_plot /), "string")

  remove_halo_all_tiles := new((/ num_tiles_to_plot /), "logical")

  nhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nyhSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxSG_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nySG_all_tiles := new((/ num_tiles_to_plot /), "integer")

  nh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nxh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nyh_all_tiles := new((/ num_tiles_to_plot /), "integer")
  nx_all_tiles := new((/ num_tiles_to_plot /), "integer")
  ny_all_tiles := new((/ num_tiles_to_plot /), "integer")

  coord_data_type_all_tiles := new((/ num_tiles_to_plot /), "string")

  print("")
  print("" + separator_line)
  print("Setting grid file name and dimensions of each specified tile ...")

  do nn=0, num_tiles_to_plot-1

    print("")
    msg := "nn = " + nn
    print("" + msg)
    underline = repeat_str("-", strlen(msg))
    print("" + underline)

    n_tile = tile_inds(nn)
    print("")
    print("  n_tile = " + n_tile)
;
; **********************************************************************
;
; Set the file name (including path) for the current tile.  Then save
; the resut in the grid_fn_all_tiles array for later use.
;
; **********************************************************************
;
    grid_fn = cres + "_grid.tile" + n_tile
    if (strcmp_exact(gtype, "regional") .and. (n_tile .eq. 7)) then
      grid_fn = grid_fn + ".halo" + tostring(nhalo_T7) + ".nc"

;      grid_fn = work_dir + "/shave/" + grid_fn

;The following is just a temporary fix to get plots for Jeff's real_time 
;runs which don't use the latest directory structure.  The above is still
; the correct way to do it in general
temp_dir := str_sub_str(run_dir, "run_dirs", "work_dirs")
;temp_dir := str_sub_str(temp_dir, "2019062300", "shave")
indx := str_index_of_substr(temp_dir, "/", -1)
temp_dir := str_get_cols(temp_dir, 0, indx-1)
print("run_dir = " + char_dq + run_dir + char_dq)
print("temp_dir = " + char_dq + temp_dir + char_dq)
pause
grid_fn = temp_dir + "/shave/" + grid_fn

    else
      grid_fn = grid_fn + ".nc"
      grid_fn = work_dir + "/grid/" + grid_fn
    end if

    grid_fn_all_tiles(nn) = grid_fn
    print("  grid_fn_all_tiles(" + nn + ") = " + \
          char_dq + grid_fn_all_tiles(nn) + char_dq)
;
; **********************************************************************
;
; Open the NetCDF file containing the grid specification for the current 
; tile.
;
; **********************************************************************
;
    fp = addfile(grid_fn_all_tiles(nn), "r")
;
; **********************************************************************
;
; Set the halo width (in units of cells).  Note that this is zero unless
; we're on a regional or nested grid and and the current tile is tile 7
; (the regional or nested domain/grid).  Also, set the logical variable
; that determines whether the halo should be removed from the current 
; tile before any processing is performed.  This is set to True only if
; we're on tile 7 of a regional or nested grid and remove_rgnl_halo is
; set to True.
;
; **********************************************************************
;
    nhSG_all_tiles(nn) = 0
    remove_halo_all_tiles(nn) = False

    if ((strcmp_exact(gtype, "regional") .or. \
         strcmp_exact(gtype, "nest")) .and. \
        (n_tile .eq. 7)) then

      nhSG_all_tiles(nn) = 2*nhalo_T7
      if (remove_rgnl_halo) then
        remove_halo_all_tiles(nn) = True
      end if

    end if

    nh_all_tiles(nn) = nhSG_all_tiles(nn)/2
;
; **********************************************************************
;
; Read in the dimensions of the tile's supergrid (which has twice the 
; resolution as the tile's grid).  From these, calculate the dimensions
; of the supergrid.
;
; **********************************************************************
;
    tile_SG_dims := getfilevardimsizes(fp, "area") 

    nxhSG_all_tiles(nn) = tile_SG_dims(1)
    nyhSG_all_tiles(nn) = tile_SG_dims(0)
    nxSG_all_tiles(nn) = nxhSG_all_tiles(nn) - 2*nhSG_all_tiles(nn)
    nySG_all_tiles(nn) = nyhSG_all_tiles(nn) - 2*nhSG_all_tiles(nn)

    print("")
    print("  nhSG_all_tiles(" + nn + ") = " + nhSG_all_tiles(nn))
    print("  nxhSG_all_tiles(" + nn + ") = " + nxhSG_all_tiles(nn))
    print("  nyhSG_all_tiles(" + nn + ") = " + nyhSG_all_tiles(nn))
    print("  nxSG_all_tiles(" + nn + ") = " + nxSG_all_tiles(nn))
    print("  nySG_all_tiles(" + nn + ") = " + nySG_all_tiles(nn))
;
; **********************************************************************
;
; Calculate the dimensions of the computational grid.
;
; **********************************************************************
;
    nxh_all_tiles(nn) = nxhSG_all_tiles(nn)/2
    nyh_all_tiles(nn) = nyhSG_all_tiles(nn)/2
    nx_all_tiles(nn) = nxh_all_tiles(nn) - 2*nh_all_tiles(nn)
    ny_all_tiles(nn) = nyh_all_tiles(nn) - 2*nh_all_tiles(nn)

    print("")
    print("  nh_all_tiles(" + nn + ") = " + nh_all_tiles(nn))
    print("  nxh_all_tiles(" + nn + ") = " + nxh_all_tiles(nn))
    print("  nyh_all_tiles(" + nn + ") = " + nyh_all_tiles(nn))
    print("  nx_all_tiles(" + nn + ") = " + nx_all_tiles(nn))
    print("  ny_all_tiles(" + nn + ") = " + ny_all_tiles(nn))
;
; **********************************************************************
;
; Get the data type of the x coordinate in the grid specification file.
; We assume here that the x and y coordinates have the same data type.
;
; **********************************************************************
;
    coord_data_type_all_tiles(nn) = getfilevartypes(fp, "x") 

    print("")
    print("  coord_data_type_all_tiles(" + nn + ") = " + \
          char_dq + coord_data_type_all_tiles(nn) + char_dq)

  end do

  print("")
  print("Done setting grid file name and dimensions of each specified tile.")
  print("" + separator_line)
;
; **********************************************************************
;
; Compare the coordinate data types of all tiles.  For simplicity, we
; will require that all tiles have the same coordinate data type.  If 
; this is not the case, print out an error message and exit.
;
; **********************************************************************
;
  coord_data_type := coord_data_type_all_tiles(0)

  if (num_tiles_to_plot .gt. 1) then

    match_found \
    := strcmp_exact( \
       coord_data_type_all_tiles(1:num_tiles_to_plot-1), \
       coord_data_type)
    match_by_elem = match_found@match_by_elem

    if (.not. all(match_by_elem)) then

      msg := "  coord_data_type_all_tiles(" \
           + ispan(0, num_tiles_to_plot-1, 1) \
           + ") = " + char_dq + coord_data_type_all_tiles + char_dq
      msg := str_join(msg, char_nl)

      msg := char_nl + \
"For simplicity, we require that the coordinate arrays in the files cor-" + char_nl + \
"responding to the specified tiles all have the same data type.  In this " + char_nl + \
"case, they are not:" + char_nl + \
msg + char_nl + \
"Stopping."

      print("" + msg)
      exit

    end if

  end if

  msg := char_nl + \
"The data type of the coordinates in the grid specification files for " + char_nl + \
"all tiles is:" + char_nl + \
"  coord_data_type = " + char_dq + coord_data_type + char_dq
  print("" + msg)
;
; **********************************************************************
;
; Initialize the arrays that will contain the grid and boundary coordi-
; nates of all specified tiles to 1-element arrays containing missing
; values of type coord_data_type.  After the coordinates are appended to
; these arrays in the loop below, the first elements of these arrays
; will be stripped away (since they are created here only to make it 
; convenient to append to the arrays).
;
; **********************************************************************
;
  lon_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lat_cntrs_all_tiles_unstruc := new(1, coord_data_type)
  lon_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lat_verts_all_tiles_unstruc := new((/1,4/), coord_data_type)
  lon_bdy_all_tiles := new(1, coord_data_type)
  lat_bdy_all_tiles := new(1, coord_data_type)
;
; **********************************************************************
;
; Initialize the arrays that will contain the coorinates of the tile 
; centers and the tile corners and midpoints to missing values of type
; coord_data_type.
;
; **********************************************************************
;
  lon_tile_cntr_all_tiles := new((/ num_tiles_to_plot /), coord_data_type)
  lat_tile_cntr_all_tiles := new((/ num_tiles_to_plot /), coord_data_type)

  lon_tile_corners_face_midpts_all_tiles \
  := new((/ num_tiles_to_plot, 8 /), coord_data_type)
  lat_tile_corners_face_midpts_all_tiles \
  := new((/ num_tiles_to_plot, 8 /), coord_data_type)
;
; **********************************************************************
;
; Loop through the specified tiles and read in and process coordinate 
; arrays.
;
; **********************************************************************
;
  print("")
  print("" + separator_line)
  print("Reading in grid coordinates of each specified tile from file ...")

  do nn=0, num_tiles_to_plot-1

    n_tile = tile_inds(nn)
    print("")
    print("  n_tile = " + n_tile)
;
; **********************************************************************
;
; Get grid dimensions of current tile.
;
; **********************************************************************
;
    nhSG = nhSG_all_tiles(nn)
    nxhSG = nxhSG_all_tiles(nn)
    nyhSG = nyhSG_all_tiles(nn)
    nxSG = nxSG_all_tiles(nn)
    nySG = nySG_all_tiles(nn)

    nh = nh_all_tiles(nn)
    nxh = nxh_all_tiles(nn)
    nyh = nyh_all_tiles(nn)
    nx = nx_all_tiles(nn)
    ny = ny_all_tiles(nn)

    remove_halo = remove_halo_all_tiles(nn)
;
; **********************************************************************
;
; Open the NetCDF file containing the grid specification for the current 
; tile.
;
; **********************************************************************
;
    fp = addfile(grid_fn_all_tiles(nn), "r")
;
; **********************************************************************
;
; Read in the supergrid coordinates.  The supergrid of a given tile is a
; grid having twice the resolution of the actual (i.e. computational) 
; grid of that tile.  It is used to store the coordintes of both the 
; centers and the vertices of the cells on the computational grid.
;
; **********************************************************************
; 
    lon_verts_SG_crnt_tile := fp->x(:,:)
    lat_verts_SG_crnt_tile := fp->y(:,:)

    lon_verts_SG_crnt_tile \
    := adjust_longitude_range(lon_verts_SG_crnt_tile, -180.0d+0, "degs")
;
; **********************************************************************
;
; Get the coordinates of the cell vertices on the current tile from 
; those of the supergrid.
;
; **********************************************************************
;
    lon_verts_crnt_tile := lon_verts_SG_crnt_tile(0::2,0::2)
    lat_verts_crnt_tile := lat_verts_SG_crnt_tile(0::2,0::2)
;
; **********************************************************************
;
; Get the coordinates of the cell centers on the current tile from those
; of the supergrid.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile := lon_verts_SG_crnt_tile(1::2,1::2)
    lat_cntrs_crnt_tile := lat_verts_SG_crnt_tile(1::2,1::2)
;
; **********************************************************************
;
; If on a regional grid, if the current tile is tile 7 (the regional do-
; main/grid), and if remove_rgnl_halo is set to True, then remove a halo
; of width nhalo_T7 cells from each of the coordinate arrays.
;
; **********************************************************************
;
    if (remove_halo) then

      print("")
      print("  Removing halo cells from coordinate arrays of tile " + \
            n_tile + " ...")
;
; **********************************************************************
;
; Remove halo cells from the arrays containing coordinates of the cell
; vertices of the supergrid.
;
; **********************************************************************
;
      lon_verts_SG_crnt_tile \
      := lon_verts_SG_crnt_tile(nhSG:nyhSG-nhSG, nhSG:nxhSG-nhSG)
      lat_verts_SG_crnt_tile \
      := lat_verts_SG_crnt_tile(nhSG:nyhSG-nhSG, nhSG:nxhSG-nhSG)
;
; **********************************************************************
;
; Remove halo cells from the arrays containing the coordinates of cell
; centers of the computational grid.
;
; **********************************************************************
;
      lon_cntrs_crnt_tile \
      := lon_cntrs_crnt_tile(nh:nyh-1-nh, nh:nxh-1-nh)
      lat_cntrs_crnt_tile \
      := lat_cntrs_crnt_tile(nh:nyh-1-nh, nh:nxh-1-nh)
;
; **********************************************************************
;
; Remove halo cells from the arrays containing coordinates of the cell
; vertices of the computational grid.
;
; **********************************************************************
;
      lon_verts_crnt_tile := lon_verts_crnt_tile(nh:nyh-nh, nh:nxh-nh)
      lat_verts_crnt_tile := lat_verts_crnt_tile(nh:nyh-nh, nh:nxh-nh)

      print("  Done removing halo cells from coordinate arrays of " + \
            "tile " + n_tile + ".")

    end if
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the center of each cell on the current tile.  Note that these are 1-D
; arrays, and their size (i.e. the number of elements they contain) is 
; equal to the number of cells on the current tile's grid (i.e. nxh*nyh
; or nx*ny).  This unstructured format is useful for generating color-
; contour plots of fields on the grid that have one value per cell re-
; presented by a flat color in that cell.
;
; **********************************************************************
;
    lon_cntrs_crnt_tile_unstruc := ndtooned(lon_cntrs_crnt_tile)
    lat_cntrs_crnt_tile_unstruc := ndtooned(lat_cntrs_crnt_tile)
;
; **********************************************************************
;
; Create arrays in unstructured format that contain the coordinates of
; the vertices of each cell on the current tile.  Note that these are 
; 2-D arrays whose first dimension size is the number of cells on the 
; current tile's grid (i.e. nxh*nyh or nx*ny) and whose second dimension
; size is 4 (since each cell has 4 vertices).  This unstructured format
; is useful for generating color-contour plots of fields on the grid 
; that have one value per cell represented by a flat color in that cell.
;
; **********************************************************************
;
    lon_verts_crnt_tile_unstruc \
    := (/ ndtooned(lon_verts_crnt_tile(0:ny-1,0:nx-1)), \
          ndtooned(lon_verts_crnt_tile(0:ny-1,1:nx)), \
          ndtooned(lon_verts_crnt_tile(1:ny,1:nx)), \
          ndtooned(lon_verts_crnt_tile(1:ny,0:nx-1)) /)
    lon_verts_crnt_tile_unstruc \
    := transpose(lon_verts_crnt_tile_unstruc)

    lat_verts_crnt_tile_unstruc \
    := (/ ndtooned(lat_verts_crnt_tile(0:ny-1,0:nx-1)), \
          ndtooned(lat_verts_crnt_tile(0:ny-1,1:nx)), \
          ndtooned(lat_verts_crnt_tile(1:ny,1:nx)), \
          ndtooned(lat_verts_crnt_tile(1:ny,0:nx-1)) /)
    lat_verts_crnt_tile_unstruc \
    := transpose(lat_verts_crnt_tile_unstruc)
;
; **********************************************************************
;
; Append to the unstructured arrays that will contain the coordinates of
; the cell centers and cell vertices on all specified tiles.  We refer 
; to these as the "all-tiles" arrays.
;
; **********************************************************************
;
    lon_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lon_cntrs_all_tiles_unstruc, lon_cntrs_crnt_tile_unstruc, 0)
    lat_cntrs_all_tiles_unstruc \
    := array_append_record( \
       lat_cntrs_all_tiles_unstruc, lat_cntrs_crnt_tile_unstruc, 0)

    lon_verts_all_tiles_unstruc \
    := array_append_record( \
       lon_verts_all_tiles_unstruc, lon_verts_crnt_tile_unstruc, 0)
    lat_verts_all_tiles_unstruc \
    := array_append_record( \
       lat_verts_all_tiles_unstruc, lat_verts_crnt_tile_unstruc, 0)
;
; **********************************************************************
;
; If get_tile_bdies is True, generate unstructured boundary coordinate
; arrays.
;
; **********************************************************************
;
    if (get_tile_bdies) then
;
; First, get the coordinates of the boundary points on the current tile.
; Here, by "boundary points", we mean those cell vertices that happen to
; lie on the tile's boundary.
;
      repeat_last_point = True
      array_order = "ji"
      bdy_info := get_rect_grid_bdy( \
                  lon_verts_crnt_tile, lat_verts_crnt_tile, \
                  repeat_last_point, array_order)
      lon_bdy_crnt_tile := bdy_info@x_bdy
      lat_bdy_crnt_tile := bdy_info@y_bdy
;
; Append to the arrays that will contain the coordinates of the boundary
; points on all specified tiles.  We refer to these as the "all-tiles" 
; arrays.
;
      lon_bdy_all_tiles \
      := array_append_record(lon_bdy_all_tiles, lon_bdy_crnt_tile, 0)
      lat_bdy_all_tiles \
      := array_append_record(lat_bdy_all_tiles, lat_bdy_crnt_tile, 0)

    end if
;
; **********************************************************************
;
; Find and print out the coordinates of the corners of the current tile.
;
; **********************************************************************
;
    x_is_longitude = True
    opts := True
    opts@verbose = False
    corner_info := get_rect_grid_corners( \
                   lon_verts_crnt_tile, lat_verts_crnt_tile, \
                   "deg", "deg", x_is_longitude, opts)
    corner_lons := corner_info@x_corners
    corner_lats := corner_info@y_corners

    print("")
    print("  Tile corner lon/lat coordinates are:")
    fmt_str = "%7.2f"
    do c=0, dimsizes(corner_lons)-1
      lon_str = sprintf(fmt_str, corner_lons(c))
      lat_str = sprintf(fmt_str, corner_lats(c))
      print("    Corner " + (c+1) + ":  lon = " + lon_str + " deg;  " + \
            "lat = " + lat_str + " deg")
    end do
;
; **********************************************************************
;
; Set the i-indices of the domain's left (west) boundary, center, and 
; right (east) boundary and the j-indices of the bottom (south) bounda-
; ry, middle (center), and top (north) boundary in the arrays containing
; the coordinates of the supergrid.
;
; **********************************************************************
;
    if (remove_halo) then

      i_left = 0
      i_cntr = nxSG/2
      i_rght = nxSG

      j_bot = 0
      j_mid = nySG/2
      j_top = nySG

    else

      i_left = 0
      i_cntr = nxhSG/2
      i_rght = nxhSG

      j_bot = 0
      j_mid = nyhSG/2
      j_top = nyhSG

    end if
;
; **********************************************************************
;
; Calculate the coordinates of the center of the current tile as well as
; the coordinates of the tile corners and the midpoints of the four tile
; faces.
;
; **********************************************************************
;
    lon_tile_cntr_all_tiles(nn) = lon_verts_SG_crnt_tile(j_mid, i_cntr)
    lat_tile_cntr_all_tiles(nn) = lat_verts_SG_crnt_tile(j_mid, i_cntr)

    loc_names := new(8, "string")

    i = 0
    loc_names(i) = "SW_corner"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_bot, i_left)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_bot, i_left)

    i = i + 1
    loc_names(i) = "S_face_midpt"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_bot, i_cntr)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_bot, i_cntr)

    i = i + 1
    loc_names(i) = "SE_corner"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_bot, i_rght)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_bot, i_rght)

    i = i + 1
    loc_names(i) = "E_face_midpt"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_mid, i_rght)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_mid, i_rght)

    i = i + 1
    loc_names(i) = "NE_corner"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_top, i_rght)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_top, i_rght)

    i = i + 1
    loc_names(i) = "N_face_midpt"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_top, i_cntr)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_top, i_cntr)

    i = i + 1
    loc_names(i) = "NW_corner"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_top, i_left)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_top, i_left)

    i = i + 1
    loc_names(i) = "W_face_midpt"
    lon_tile_corners_face_midpts_all_tiles(nn,i) \
    = lon_verts_SG_crnt_tile(j_mid, i_left)
    lat_tile_corners_face_midpts_all_tiles(nn,i) \
    = lat_verts_SG_crnt_tile(j_mid, i_left)
;
; **********************************************************************
;
; Print out the coordinates of grid corners and face midpoints.
;
; **********************************************************************
;
    lon_str := sprintf("%10.6f", lon_tile_corners_face_midpts_all_tiles(nn,:))
    lat_str := sprintf("%10.6f", lat_tile_corners_face_midpts_all_tiles(nn,:))
    
    loc_names := strpad(loc_names + ":", " ", "right")
    lon_str := strpad(lon_str + " deg", " ", "left")
    lat_str := strpad(lat_str + " deg", " ", "left")
    msg := loc_names + "  lon = " + lon_str + ";  lat = " + lat_str
    msg := array_append_record( \
"Longitudes and latitudes of the tile corners and tile face midpoints are:", \
           "  " + msg, 0)
    msg := "  " + msg
    msg := str_join(msg, char_nl)
    print("")
    print("" + msg)

  end do

  print("")
  print("Done reading in grid coordinates of each specified tile.")
  print("" + separator_line)
;
; **********************************************************************
;
; Remove the first elements in the unstructured arrays containing the
; coordinates of the grid cells and tile boundaries.  Recall that these
; first elements were defined to make it convenient to append the coor-
; dinates of each consecutive tile; they contain missing values of type
; coord_data_type.
;
; **********************************************************************
;
  lon_cntrs_all_tiles_unstruc := lon_cntrs_all_tiles_unstruc(1:)
  lat_cntrs_all_tiles_unstruc := lat_cntrs_all_tiles_unstruc(1:)
  lon_verts_all_tiles_unstruc := lon_verts_all_tiles_unstruc(1:,:)
  lat_verts_all_tiles_unstruc := lat_verts_all_tiles_unstruc(1:,:)
  if (get_tile_bdies) then
    lon_bdy_all_tiles := lon_bdy_all_tiles(1:)
    lat_bdy_all_tiles := lat_bdy_all_tiles(1:)
  end if
;
; **********************************************************************
;
; Return results as attributes of the logical variable grid_info.
;
; **********************************************************************
;
  grid_info := True

  grid_info@fp = fp
  grid_info@grid_fn_all_tiles = grid_fn_all_tiles

  grid_info@nhSG_all_tiles = nhSG_all_tiles
  grid_info@nxhSG_all_tiles = nxhSG_all_tiles
  grid_info@nyhSG_all_tiles = nyhSG_all_tiles
  grid_info@nxSG_all_tiles = nxSG_all_tiles
  grid_info@nySG_all_tiles = nySG_all_tiles

  grid_info@nh_all_tiles = nh_all_tiles
  grid_info@nxh_all_tiles = nxh_all_tiles
  grid_info@nyh_all_tiles = nyh_all_tiles
  grid_info@nx_all_tiles = nx_all_tiles
  grid_info@ny_all_tiles = ny_all_tiles

  grid_info@remove_halo_all_tiles = remove_halo_all_tiles

  grid_info@lon_cntrs_all_tiles_unstruc = lon_cntrs_all_tiles_unstruc
  grid_info@lat_cntrs_all_tiles_unstruc = lat_cntrs_all_tiles_unstruc
  grid_info@lon_verts_all_tiles_unstruc = lon_verts_all_tiles_unstruc
  grid_info@lat_verts_all_tiles_unstruc = lat_verts_all_tiles_unstruc

  grid_info@lon_bdy_all_tiles = lon_bdy_all_tiles
  grid_info@lat_bdy_all_tiles = lat_bdy_all_tiles

  grid_info@lon_tile_cntr_all_tiles = lon_tile_cntr_all_tiles
  grid_info@lat_tile_cntr_all_tiles = lat_tile_cntr_all_tiles

  grid_info@lon_tile_corners_face_midpts_all_tiles \
  = lon_tile_corners_face_midpts_all_tiles
  grid_info@lat_tile_corners_face_midpts_all_tiles \
  = lat_tile_corners_face_midpts_all_tiles
 
  grid_info@coord_data_type = coord_data_type

  return(grid_info)

end

